In SQL, sub-queries can appear inside the SELECT clause of an outer query. This is useful when the purpose is computing independent results from the same pivot table. 

For instance, suppose we want to find, for each movie, its title and the number of cast members and crew members. This can be accomplished with the following query:

SELECT m.title, (SELECT count(*) FROM movie_cast mc WHERE m.movie_id = mc.movie_id), (SELECT count(*) FROM movie_crew mc WHERE m.movie_id = mc.movie_id)
FROM movie m;

Alternatively, the JOIN LATERAL could reach the same result.

```sql
SELECT m.title, agg1.cont, agg2.cont
FROM movie m1
JOIN LATERAL (
    SELECT COUNT(*) AS cont FROM movie_cast mc
    WHERE mc.movie_id = m1.movie_id
) AS agg1 
JOIN LATERAL (
    SELECT COUNT(*) AS cont FROM movie_crew mc
    WHERE mc.movie_id = m1.movie_id
) AS agg2 
ON agg1.cont = agg2.cont;
```

Other alternative exists, such as some very inefficient ones, where the movie table has to join against movie_cast and movie_crew, and perform redundant aggregations for the unnecesary join between movie_cast and movie_crew. The sub-queries inside the select clause and the join lateral are ways to contornar this problem.



In **DBest**, this query is represented by a **tree structure**, where processing starts at the `movie` table.  

### Step-by-step execution:  



## Query Execution Steps  

1. A **nested loop left outer join** is performed with the `movie_cast` table.  
   - The **outer join** ensures that movies without cast members are included.  

2. A **`GROUP BY`** operation is applied.  

3. This `GROUP BY` operation retains three columns:  
   - **`movie_id`** → The grouping column.  
   - **`title`** → Computed using the `FIRST` aggregation function.  
     - This function takes the first occurrence of the title within the group, but any occurrence would work.  
   - **`cast_count`** → Computed using the `COUNT` aggregation function.  

4. The same process is repeated for the `movie_crew` table:  
   - Another **outer join** is followed by a **`GROUP BY`** operation to compute the crew member count.  

5. The second `GROUP BY` operation retains four columns:  
   - **`movie_id`** → The grouping column.  
   - **`title`** → Retrieved from the previous aggregation using the `FIRST` function. 
   - **`cast_count`** → Retrieved from the previous aggregation using the `FIRST` function.  
   - **`crew_count`** → Computed using the `COUNT` aggregation function.  



A **very similar query plan** was used to solve a query that included a **subquery in the `FROM` clause**, as shown in the previous section.  The only distinction is that **no filter is applied** as a final step.  

Subqueries in the `SELECT` clause are a **special case** of subqueries that utilize the **`LATERAL JOIN`** clause.  The `LATERAL JOIN` approach is **more general** and allows for **additional computations**, such as applying filters.  
Since both methods rely on **similar logical steps**, their **query plans are almost identical**.  




