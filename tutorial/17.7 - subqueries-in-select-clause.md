In SQL, sub-queries can appear inside the SELECT clause of an outer query. This is useful when the purpose is computing independent results from the same pivot table. 

For instance, suppose we want to find, for each movie, its title and the number of cast members and crew members. This can be accomplished with the following query:

SELECT m.title, (SELECT count(*) FROM movie_cast mc WHERE m.movie_id = mc.movie_id), (SELECT count(*) FROM movie_crew mc WHERE m.movie_id = mc.movie_id)
FROM movie m;

Alternatively, the JOIN LATERAL could reach the same result.

```sql
SELECT m.title, agg1.cont, agg2.cont
FROM movie m1
JOIN LATERAL (
    SELECT COUNT(*) AS cont FROM movie_cast mc
    WHERE mc.movie_id = m1.movie_id
) AS agg1 
JOIN LATERAL (
    SELECT COUNT(*) AS cont FROM movie_crew mc
    WHERE mc.movie_id = m1.movie_id
) AS agg2 
ON agg1.cont = agg2.cont;
```

Other alternative exists, such as some very inefficient ones, where the movie table has to join against movie_cast and movie_crew, and perform redundant aggregations for the unnecesary join between movie_cast and movie_crew. The sub-queries inside the select clause and the join lateral are ways to contornar this problem.



In **DBest**, this query is represented by a **tree structure**, where processing starts at the `movie` table.  

### Step-by-step execution:  

1. A **nested loop left outer join** is performed with the `movie_cast` table. The **outer join** ensures that movies without cast members are included.
2. A **`GROUP BY`** operator computes the number of cast members.
4. This operator retains three columns 
   - the movie_id (the grouping column)
   - the title, computed by the FIRST aggregation function). Basically, this function takes the first occurence of title within the group, but any occurrence would be ok.
   - the cast count, computed by the COUNT aggregation function. 
5. The same process is repeated for the `movie_crew` table:  
   - Another **outer join** is followed by a **`GROUP BY`** operator to compute the crew member count.  
6. The second `GROUP BY` operation retains four columns:  
   - `movie_id` (the grouping column)
   - title, computed by the FIRST aggregation function. 
   - cast members, computed by the FIRST aggregation function.  
   - Crew member count, computed by the COUNT aggregation function.   
8. Finally, a **filter operator** ensures that the cast and crew counts are equal.  
