# Handling `NOT EXISTS` and `NOT IN`  

The first example retrieves movies that do not have cast member. The query below uses `NOT EXISTS`, where the subquery checks if a matching `movie_id` exists in the `movie_cast` table. If a match is not found, the movie is included in the result set.  

```sql
SELECT * FROM movie m  
WHERE NOT EXISTS (  
    SELECT 1 FROM movie_cast mc  
    WHERE m.movie_id = mc.movie_id  
);
```

Since the correlated condition uses **equality**, the query can also be expressed with `IN`, as shown below. The movie is considered relevant if its `movie_id` does not appear in a list of `movie_ids` associated with cast members.

```sql
SELECT * FROM movie  
WHERE movie_id NOT IN (  
    SELECT movie_id FROM movie_cast  
);
```

We present two primary ways to represent this query in **DBest**:  

- **Without Materialization (left approach):** The execution is fully pipelined, with the **Nested Loop Anti Join** directly searching for matching `movie_id`s in the `movie_cast` table.  
- **With Materialization  (right approach):** The **Hash** operator materializes `movie_cast` tuples in a **hash table**, enabling the **Nested Loop Anti Join** to perform efficient lookups.  
  - Alternatively, a **Hash Left Anti Join** can replace the **Nested Loop Anti Join + Hash** combination.  


<img src="assets/images/in vs exists 1.png" alt="Expressing IN and EXISTS subqueries" width="800"/>


**Materialization** is preferable when there are many lookups since it avoids repeated index accesses. **Pipelined execution** is better for a small number of lookups, as it eliminates materialization overhead.  

It is important to note that, as with the IN/EXISTS comparison,  NOT EXISTS has more expressive power than NOT IN, because it supports conditions other like equality. 






### Finding Movies Released in the Same Year as *Casablanca*

The previous example shows a case where a query could be expressed with either NOT IN or NOT EXISTS. It is not always the case. If the list produced by the NOT IN subquery contains nulls values, than the query will return en empty result set. The reason is related to the null semantics. 


Consider the SQL query below.  The query returns movies whose title is not a character name. All titles that satisfy this restritction are returned, regardless of the existence of  character names with null values.

```sql
SELECT * FROM movie m
WHERE NOT EXISTS (  
    SELECT 1 FROM movie_cast mc WHERE m.title = mc.title
);
```
Now consider the NOT IN counterpart. For each movie, it checks for matches within the list of character names returned by the subquery. 
If the list contains null values, it is not possible to state that a title is not contained within the list, because the value hidden behind the null is unknown. To avoind returning uncertain results, the NOT IN version returns no tuples.  

```sql
SELECT * FROM movie  
WHERE title NOT IN (  
    SELECT character_name FROM movie_cast
);
```

Now lets express these two requests in DBest. 
The 

One way to represent this query in **DBest** is by materializing the `movie_cast` tuples. Since the number of movies titled *Casablanca* is expected to be small, the cost of materialization remains low.  

Two different approaches to materialization are discussed:  

- **Materialized Operator (Left Approach):**  
  - Stores *Casablanca* movies in memory.  
  - Requires a **full scan** over the materialized tuples for each lookup, as indexed search is not supported.  

- **Hash Operator (Right Approach):**  
  - Stores *Casablanca* movies in a **hash table** for quick lookups.  
  - Given a movie, the **hash table** is queried directly to find matching tuples.  

Since the number of materialized tuples is small, both strategies should perform similarly.  



<img src="assets/images/in vs exists 2.png" alt="Expressing IN and EXISTS subqueries" width="900"/>




